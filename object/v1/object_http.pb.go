// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.4.0
// - protoc             v3.20.1
// source: object/v1/object.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationObjectCreateObject = "/api.object.v1.Object/CreateObject"
const OperationObjectDeleteObject = "/api.object.v1.Object/DeleteObject"
const OperationObjectGetObject = "/api.object.v1.Object/GetObject"
const OperationObjectListObject = "/api.object.v1.Object/ListObject"
const OperationObjectUpdateObject = "/api.object.v1.Object/UpdateObject"

type ObjectHTTPServer interface {
	CreateObject(context.Context, *CreateObjectRequest) (*CreateObjectReply, error)
	DeleteObject(context.Context, *DeleteObjectRequest) (*DeleteObjectReply, error)
	GetObject(context.Context, *GetObjectRequest) (*GetObjectReply, error)
	ListObject(context.Context, *ListObjectRequest) (*ListObjectReply, error)
	UpdateObject(context.Context, *UpdateObjectRequest) (*UpdateObjectReply, error)
}

func RegisterObjectHTTPServer(s *http.Server, srv ObjectHTTPServer) {
	r := s.Route("/")
	r.PUT("/api/v1/object", _Object_CreateObject0_HTTP_Handler(srv))
	r.POST("/api/v1/object/{id}", _Object_UpdateObject0_HTTP_Handler(srv))
	r.DELETE("/api/v1/object/{id}", _Object_DeleteObject0_HTTP_Handler(srv))
	r.GET("/api/v1/object/{id}", _Object_GetObject0_HTTP_Handler(srv))
	r.GET("/api/v1/objects", _Object_ListObject0_HTTP_Handler(srv))
}

func _Object_CreateObject0_HTTP_Handler(srv ObjectHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateObjectRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationObjectCreateObject)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateObject(ctx, req.(*CreateObjectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateObjectReply)
		return ctx.Result(200, reply)
	}
}

func _Object_UpdateObject0_HTTP_Handler(srv ObjectHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateObjectRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationObjectUpdateObject)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateObject(ctx, req.(*UpdateObjectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateObjectReply)
		return ctx.Result(200, reply)
	}
}

func _Object_DeleteObject0_HTTP_Handler(srv ObjectHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteObjectRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationObjectDeleteObject)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteObject(ctx, req.(*DeleteObjectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteObjectReply)
		return ctx.Result(200, reply)
	}
}

func _Object_GetObject0_HTTP_Handler(srv ObjectHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetObjectRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationObjectGetObject)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetObject(ctx, req.(*GetObjectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetObjectReply)
		return ctx.Result(200, reply)
	}
}

func _Object_ListObject0_HTTP_Handler(srv ObjectHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListObjectRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationObjectListObject)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListObject(ctx, req.(*ListObjectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListObjectReply)
		return ctx.Result(200, reply)
	}
}

type ObjectHTTPClient interface {
	CreateObject(ctx context.Context, req *CreateObjectRequest, opts ...http.CallOption) (rsp *CreateObjectReply, err error)
	DeleteObject(ctx context.Context, req *DeleteObjectRequest, opts ...http.CallOption) (rsp *DeleteObjectReply, err error)
	GetObject(ctx context.Context, req *GetObjectRequest, opts ...http.CallOption) (rsp *GetObjectReply, err error)
	ListObject(ctx context.Context, req *ListObjectRequest, opts ...http.CallOption) (rsp *ListObjectReply, err error)
	UpdateObject(ctx context.Context, req *UpdateObjectRequest, opts ...http.CallOption) (rsp *UpdateObjectReply, err error)
}

type ObjectHTTPClientImpl struct {
	cc *http.Client
}

func NewObjectHTTPClient(client *http.Client) ObjectHTTPClient {
	return &ObjectHTTPClientImpl{client}
}

func (c *ObjectHTTPClientImpl) CreateObject(ctx context.Context, in *CreateObjectRequest, opts ...http.CallOption) (*CreateObjectReply, error) {
	var out CreateObjectReply
	pattern := "/api/v1/object"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationObjectCreateObject))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ObjectHTTPClientImpl) DeleteObject(ctx context.Context, in *DeleteObjectRequest, opts ...http.CallOption) (*DeleteObjectReply, error) {
	var out DeleteObjectReply
	pattern := "/api/v1/object/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationObjectDeleteObject))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ObjectHTTPClientImpl) GetObject(ctx context.Context, in *GetObjectRequest, opts ...http.CallOption) (*GetObjectReply, error) {
	var out GetObjectReply
	pattern := "/api/v1/object/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationObjectGetObject))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ObjectHTTPClientImpl) ListObject(ctx context.Context, in *ListObjectRequest, opts ...http.CallOption) (*ListObjectReply, error) {
	var out ListObjectReply
	pattern := "/api/v1/objects"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationObjectListObject))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ObjectHTTPClientImpl) UpdateObject(ctx context.Context, in *UpdateObjectRequest, opts ...http.CallOption) (*UpdateObjectReply, error) {
	var out UpdateObjectReply
	pattern := "/api/v1/object/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationObjectUpdateObject))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
