// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.4.0
// - protoc             v3.20.0
// source: api/video/v1/video.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationVideoDeleteProxy = "/api.video.v1.Video/DeleteProxy"
const OperationVideoFindChannels = "/api.video.v1.Video/FindChannels"
const OperationVideoFindDevices = "/api.video.v1.Video/FindDevices"
const OperationVideoStartPlay = "/api.video.v1.Video/StartPlay"
const OperationVideoStartProxy = "/api.video.v1.Video/StartProxy"
const OperationVideoStopPlay = "/api.video.v1.Video/StopPlay"
const OperationVideoStopProxy = "/api.video.v1.Video/StopProxy"

type VideoHTTPServer interface {
	DeleteProxy(context.Context, *DeleteProxyRequest) (*DeleteProxyReply, error)
	FindChannels(context.Context, *FindChannelsRequest) (*FindChannelsReply, error)
	FindDevices(context.Context, *FindDevicesRequest) (*FindDevicesReply, error)
	StartPlay(context.Context, *StartPlayRequest) (*StartPlayReply, error)
	StartProxy(context.Context, *StartProxyRequest) (*StartProxyReply, error)
	StopPlay(context.Context, *StopPlayRequest) (*StopPlayReply, error)
	StopProxy(context.Context, *StopProxyRequest) (*StopProxyReply, error)
}

func RegisterVideoHTTPServer(s *http.Server, srv VideoHTTPServer) {
	r := s.Route("/")
	r.POST("/api/v1/gb/device/find", _Video_FindDevices0_HTTP_Handler(srv))
	r.POST("/api/v1/gb/channel/find", _Video_FindChannels0_HTTP_Handler(srv))
	r.POST("/api/v1/gb/start", _Video_StartPlay0_HTTP_Handler(srv))
	r.POST("/api/v1/gb/stop", _Video_StopPlay0_HTTP_Handler(srv))
	r.POST("/api/v1/proxy/start", _Video_StartProxy0_HTTP_Handler(srv))
	r.POST("/api/v1/proxy/stop", _Video_StopProxy0_HTTP_Handler(srv))
	r.POST("/api/v1/proxy/delete", _Video_DeleteProxy0_HTTP_Handler(srv))
}

func _Video_FindDevices0_HTTP_Handler(srv VideoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FindDevicesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVideoFindDevices)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FindDevices(ctx, req.(*FindDevicesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FindDevicesReply)
		return ctx.Result(200, reply)
	}
}

func _Video_FindChannels0_HTTP_Handler(srv VideoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FindChannelsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVideoFindChannels)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FindChannels(ctx, req.(*FindChannelsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FindChannelsReply)
		return ctx.Result(200, reply)
	}
}

func _Video_StartPlay0_HTTP_Handler(srv VideoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in StartPlayRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVideoStartPlay)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StartPlay(ctx, req.(*StartPlayRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*StartPlayReply)
		return ctx.Result(200, reply)
	}
}

func _Video_StopPlay0_HTTP_Handler(srv VideoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in StopPlayRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVideoStopPlay)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StopPlay(ctx, req.(*StopPlayRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*StopPlayReply)
		return ctx.Result(200, reply)
	}
}

func _Video_StartProxy0_HTTP_Handler(srv VideoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in StartProxyRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVideoStartProxy)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StartProxy(ctx, req.(*StartProxyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*StartProxyReply)
		return ctx.Result(200, reply)
	}
}

func _Video_StopProxy0_HTTP_Handler(srv VideoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in StopProxyRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVideoStopProxy)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StopProxy(ctx, req.(*StopProxyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*StopProxyReply)
		return ctx.Result(200, reply)
	}
}

func _Video_DeleteProxy0_HTTP_Handler(srv VideoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteProxyRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVideoDeleteProxy)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteProxy(ctx, req.(*DeleteProxyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteProxyReply)
		return ctx.Result(200, reply)
	}
}

type VideoHTTPClient interface {
	DeleteProxy(ctx context.Context, req *DeleteProxyRequest, opts ...http.CallOption) (rsp *DeleteProxyReply, err error)
	FindChannels(ctx context.Context, req *FindChannelsRequest, opts ...http.CallOption) (rsp *FindChannelsReply, err error)
	FindDevices(ctx context.Context, req *FindDevicesRequest, opts ...http.CallOption) (rsp *FindDevicesReply, err error)
	StartPlay(ctx context.Context, req *StartPlayRequest, opts ...http.CallOption) (rsp *StartPlayReply, err error)
	StartProxy(ctx context.Context, req *StartProxyRequest, opts ...http.CallOption) (rsp *StartProxyReply, err error)
	StopPlay(ctx context.Context, req *StopPlayRequest, opts ...http.CallOption) (rsp *StopPlayReply, err error)
	StopProxy(ctx context.Context, req *StopProxyRequest, opts ...http.CallOption) (rsp *StopProxyReply, err error)
}

type VideoHTTPClientImpl struct {
	cc *http.Client
}

func NewVideoHTTPClient(client *http.Client) VideoHTTPClient {
	return &VideoHTTPClientImpl{client}
}

func (c *VideoHTTPClientImpl) DeleteProxy(ctx context.Context, in *DeleteProxyRequest, opts ...http.CallOption) (*DeleteProxyReply, error) {
	var out DeleteProxyReply
	pattern := "/api/v1/proxy/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVideoDeleteProxy))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VideoHTTPClientImpl) FindChannels(ctx context.Context, in *FindChannelsRequest, opts ...http.CallOption) (*FindChannelsReply, error) {
	var out FindChannelsReply
	pattern := "/api/v1/gb/channel/find"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVideoFindChannels))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VideoHTTPClientImpl) FindDevices(ctx context.Context, in *FindDevicesRequest, opts ...http.CallOption) (*FindDevicesReply, error) {
	var out FindDevicesReply
	pattern := "/api/v1/gb/device/find"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVideoFindDevices))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VideoHTTPClientImpl) StartPlay(ctx context.Context, in *StartPlayRequest, opts ...http.CallOption) (*StartPlayReply, error) {
	var out StartPlayReply
	pattern := "/api/v1/gb/start"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVideoStartPlay))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VideoHTTPClientImpl) StartProxy(ctx context.Context, in *StartProxyRequest, opts ...http.CallOption) (*StartProxyReply, error) {
	var out StartProxyReply
	pattern := "/api/v1/proxy/start"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVideoStartProxy))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VideoHTTPClientImpl) StopPlay(ctx context.Context, in *StopPlayRequest, opts ...http.CallOption) (*StopPlayReply, error) {
	var out StopPlayReply
	pattern := "/api/v1/gb/stop"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVideoStopPlay))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VideoHTTPClientImpl) StopProxy(ctx context.Context, in *StopProxyRequest, opts ...http.CallOption) (*StopProxyReply, error) {
	var out StopProxyReply
	pattern := "/api/v1/proxy/stop"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVideoStopProxy))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
